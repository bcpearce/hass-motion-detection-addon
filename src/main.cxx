#include "Logger.h"
#include "WindowsWrapper.h"

#include <array>
#include <chrono>
#include <csignal>
#include <format>
#include <iostream>
#include <memory>
#include <ranges>
#include <thread>
#include <vector>

#include <BasicUsageEnvironment.hh>

#include "Callback/AsyncFileSave.h"
#include "Callback/AsyncHassHandler.h"
#include "Callback/SyncHassHandler.h"
#include "Callback/ThreadedHassHandler.h"
#include "Detector/MotionDetector.h"
#include "Gui/WebHandler.h"
#include "Util/ProgramOptions.h"
#include "VideoSource/Http.h"
#include "VideoSource/Live555.h"
#include "VideoSource/VideoSource.h"

using namespace std::string_view_literals;
using namespace std::chrono_literals;

namespace {
struct ExitSignalHandler {
  std::vector<std::weak_ptr<video_source::VideoSource>> wpSources;
  EventLoopWatchVariable watchVar{0};
  void operator()(int signal) {
    if (signal == SIGINT || signal == SIGTERM) {
      LOGGER->info("Received signal {} closing stream...", signal);
      for (auto &wpSource : wpSources) {
        if (auto spSource = wpSource.lock()) {
          spSource->StopStream();
        }
      }
      watchVar.store(1); // Trigger the event loop to exit
    }
  }
};

static ExitSignalHandler exitSignalHandler;

void SignalHandlerWrapper(int signal) {
  exitSignalHandler(signal); // Call the functor's operator()
}

} // namespace

void EventLoopSignalHandler(int signal) {}

void App(const util::ProgramOptions &opts) {

  std::shared_ptr<TaskScheduler> pSched =
      std::shared_ptr<TaskScheduler>(BasicTaskScheduler::createNew());

  struct SourceAndHandlers {
    std::shared_ptr<video_source::VideoSource> pSource;
    std::shared_ptr<detector::MOGMotionDetector> pDetector;
    std::shared_ptr<callback::BaseHassHandler> pHassHandler;
    std::shared_ptr<callback::AsyncFileSave> pFileSaveHandler;
  };

  std::shared_ptr<gui::WebHandler> pWebHandler;
  if (opts.webUiPort > 0 && !opts.webUiHost.empty()) {
    pWebHandler =
        std::make_shared<gui::WebHandler>(opts.webUiPort, opts.webUiHost);
    LOGGER->info("Web interface started at {}", pWebHandler->GetUrl());
    pWebHandler->Start();

    std::vector<SourceAndHandlers> sources;

    for (const auto &[feedId, feedOpts] : opts.feeds) {
      LOGGER->info("Processing feed: {}", feedId);

      std::shared_ptr<video_source::VideoSource> pSource{nullptr};
      if (feedOpts.sourceUrl.scheme() == "http"sv ||
          feedOpts.sourceUrl.scheme() == "https"sv) {
        pSource = std::make_shared<video_source::HttpVideoSource>(
            feedOpts.sourceUrl, feedOpts.sourceUsername,
            feedOpts.sourcePassword);
      } else if (feedOpts.sourceUrl.scheme() == "rtsp"sv) {
        auto pLive555Source =
            std::make_shared<video_source::Live555VideoSource>(
                pSched, feedOpts.sourceUrl, feedOpts.sourceUsername,
                feedOpts.sourcePassword);
        pSource = pLive555Source;
      } else {
        LOGGER->error(
            std::format("Invalid scheme {} for URL",
                        std::string_view(feedOpts.sourceUrl.scheme())));
        continue;
      }
      sources.push_back({.pSource = pSource});

      auto pDetector = std::make_shared<detector::MOGMotionDetector>(
          detector::MOGMotionDetector::Options{.detectionSize =
                                                   feedOpts.detectionSize});

      auto onFrameCallback =
          [pDetector, mask = cv::Mat()](video_source::Frame frame) mutable {
            if (mask.size() != frame.img.size()) {
              mask = cv::Mat::zeros(frame.img.size(), frame.img.type());
              cv::rectangle(mask,
                            cv::Rect(mask.cols * 0.05, mask.rows * 0.08,
                                     mask.cols * 0.9, mask.rows * 0.84),
                            cv::Scalar(0xFF), -1);
              pDetector->mask = mask;
            }
            pDetector->FeedFrame(frame);
          };

      pSource->Subscribe(onFrameCallback);
      sources.back().pDetector = pDetector;

      std::shared_ptr<callback::BaseHassHandler> pHassHandler;
      if (opts.CanSetupHass(feedOpts)) {
        LOGGER->info(
            "Setting up Home Assistant status update for {} hosted at {}",
            feedOpts.hassEntityId, opts.hassUrl);
        if (std::dynamic_pointer_cast<video_source::HttpVideoSource>(pSource)) {
          // Require Threaded
          LOGGER->info("Running Home Assistant callbacks in separate thread");
          auto pThreadedHassHandler =
              std::make_shared<callback::ThreadedHassHandler>(
                  opts.hassUrl, opts.hassToken, feedOpts.hassEntityId);

          pThreadedHassHandler->Start();
          pHassHandler = pThreadedHassHandler;
        } else if (pSched) {
          // Optimize with Async
          LOGGER->info("Running Home Assistant callbacks in main event loop");
          auto pAsyncHassHandler = std::make_shared<callback::AsyncHassHandler>(
              pSched, opts.hassUrl, opts.hassToken, feedOpts.hassEntityId);
          pAsyncHassHandler->Register();
          pHassHandler = pAsyncHassHandler;
        }

        pHassHandler->friendlyName = feedOpts.hassFriendlyName;
        pHassHandler->debounceTime = feedOpts.detectionDebounce;

        auto onMotionDetectionCallbackHass =
            [pHassHandler](detector::Payload data) {
              pHassHandler->operator()(data.rois);
            };
        pDetector->Subscribe(onMotionDetectionCallbackHass);
        sources.back().pHassHandler = pHassHandler;
      }

      std::shared_ptr<callback::AsyncFileSave> pFileSaveHandler;
      if (opts.CanSetupFileSave(feedOpts)) {
        if (pSched) {
          pFileSaveHandler = std::make_shared<callback::AsyncFileSave>(
              pSched, opts.saveDestination / feedId, feedOpts.saveSourceUrl,
              feedOpts.sourceUsername, feedOpts.sourcePassword);
          pFileSaveHandler->Register();
          pFileSaveHandler->SetLimitSavedFilePaths(feedOpts.saveImageLimit);
          auto onMotionDetectionCallbackSave =
              [pFileSaveHandler](detector::Payload data) {
                (*pFileSaveHandler)(data);
              };
          pDetector->Subscribe(onMotionDetectionCallbackSave);
          LOGGER->info("Saving motion detection images to {}",
                       opts.saveDestination / feedId);
          sources.back().pFileSaveHandler = pFileSaveHandler;
        }
      }

      if (pWebHandler) {
        gui::WebHandler::SetSavedFilesServePath(sources.size() - 1,
                                                opts.saveDestination);
        auto onMotionDetectorCallbackGui = [pWebHandler, pDetector,
                                            pSource](detector::Payload data) {
          (*pWebHandler)({.rois = data.rois,
                          .frame = data.frame,
                          .detail = pDetector->GetModel(),
                          .fps = pSource->GetFramesPerSecond()});
        };
        pDetector->Subscribe(onMotionDetectorCallbackGui);
      }
    }

    std::signal(SIGINT, SignalHandlerWrapper);
    std::signal(SIGTERM, SignalHandlerWrapper);
    for (auto pSource :
         sources | std::views::transform(&SourceAndHandlers::pSource)) {
      if (pSource) {
        exitSignalHandler.wpSources.push_back(pSource);
        pSource->StartStream();
      }
    }

    pSched->doEventLoop(&exitSignalHandler.watchVar);

    // At this point, performance is no longer critical as the feed is shut
    // down, send the last message using a synchronous handler
    for (auto pHassHandler :
         sources | std::views::transform(&SourceAndHandlers::pHassHandler)) {
      if (pHassHandler) {
        callback::SyncHassHandler syncHandler(opts.hassUrl, opts.hassToken,
                                              pHassHandler->entityId);
        syncHandler.friendlyName = pHassHandler->friendlyName;
        syncHandler({});
      }
    }
  }
}

int main(int argc, const char **argv) {
  try {
    auto stdoutLogger = logger::InitStderrLogger();
    auto stderrLogger = logger::InitStdoutLogger();
    const auto optsVar = util::ProgramOptions::ParseOptions(argc, argv);
    if (std::holds_alternative<std::string>(optsVar)) {
      std::cout << std::get<std::string>(optsVar) << "\n";
    } else {
      App(std::get<util::ProgramOptions>(optsVar));
    }
  } catch (const std::exception &e) {
    ERR_LOGGER->critical(e.what());
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}